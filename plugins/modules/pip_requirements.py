#!/usr/bin/python3
# -*- coding: utf-8 -*-

# (c) 2020-2023, Bodo Schulz <bodo@boone-schulz.de>
# Apache-2.0 (see LICENSE or https://opensource.org/license/apache-2-0)
# SPDX-License-Identifier: Apache-2.0

from __future__ import absolute_import, print_function

from ansible.module_utils.basic import AnsibleModule
from ansible_collections.bodsch.core.plugins.module_utils.directory import create_directory
from ansible_collections.bodsch.core.plugins.module_utils.checksum import Checksum
from ansible_collections.bodsch.core.plugins.module_utils.template.template import write_template

import os
import os.path

__metaclass__ = type

# ---------------------------------------------------------------------------------------


DOCUMENTATION = """
module: pip_requirements
version_added: 1.0.16
author: "Bodo Schulz (@bodsch) <bodo@boone-schulz.de>"

short_description: This modules creates an requirement file to install python modules via pip.

description:
    - This modules creates an requirement file to install python modules via pip.

options:
  state:
    description:
      - Whether to install (C(present)), or remove (C(absent)) a package.
    required: true
  name:
    description:
      - Name of the running module.
      - Needed to create the requirements file and the checksum
    type: str
    required: true
  requirements:
    description:
      - A list with all python modules to install.
    type: list
    required: true
"""

EXAMPLES = """
- name: create pip requirements file
  bodsch.core.pip_requirements:
    name: docker
    state: present
    requirements:
      - name: docker
        compare_direction: "=="
        version: 6.0.0

      - name: setuptools
        version: 39.1.0

      - name: requests
        versions:
          - ">= 2.28.0"
          - "< 2.30.0"
          - "!~ 1.1.0"
  register: pip_requirements
"""

RETURN = """
pip_present:
  description:
    - true if `pip` or `pip3` binary found
  type: bool
requirements_file:
  description:
    - the created requirements file
  type: str
"""

# ---------------------------------------------------------------------------------------

TPL_REQUIREMENTS = """# generated by ansible

#  # It is possible to specify requirements as plain names.
#  pytest
#  pytest-cov
#  beautifulsoup4
#
#  # The syntax supported here is the same as that of requirement specifiers.
#  docopt == 0.6.1
#  requests [security] >= 2.8.1, == 2.8.* ; python_version < "2.7"

{% for k in item.split(':') %}
{{ k }}
{% endfor %}

"""


class PipRequirements():
    """
      Main Class
    """
    module = None

    def __init__(self, module):
        """

        """
        self.module = module

        self.state = module.params.get("state")
        self.name = module.params.get("name")
        self.requirements = module.params.get("requirements")

        self.cache_directory = "/var/cache/ansible/pip_requirements"
        self.requirements_file_name = os.path.join(self.cache_directory, f"{self.name}.txt")
        self.checksum_file_name = os.path.join(self.cache_directory, f"{self.name}.checksum")

    def run(self):
        """
        """
        # self.module.log(msg=f"{self.name}:")
        # self.module.log(msg=f"  {self.requirements}")

        create_directory(self.cache_directory)

        _changed = False
        _msg = "There are no changes."

        checksum = None

        if self.state == "absent":
            if os.path.exists(self.cache_directory):
                os.remove(self.requirements_file_name)
                os.remove(self.checksum_file_name)
                _changed = True
                _msg = "The pip requirements have been successfully removed."

            return dict(
                changed=_changed,
                msg=_msg
            )

        checksum = Checksum(self.module)

        changed, new_checksum, old_checksum = checksum.validate(self.checksum_file_name, self.requirements)

        # self.module.log(f" changed       : {changed}")
        # self.module.log(f" new_checksum  : {new_checksum}")
        # self.module.log(f" old_checksum  : {old_checksum}")

        self.pip_binary = self.module.get_bin_path('pip3', False)

        if not self.pip_binary:
            self.pip_binary = self.module.get_bin_path('pip', False)

        if not self.pip_binary:
            pip_present = False
        else:
            pip_present = True

        if not changed:
            return dict(
                changed=False,
                requirements_file=self.requirements_file_name,
                pip=dict(
                    present=pip_present,
                    bin_path=self.pip_binary
                )
            )

        req = self.pip_requirements(self.requirements)

        write_template(self.requirements_file_name, TPL_REQUIREMENTS, req)

        checksum.write_checksum(self.checksum_file_name, new_checksum)

        return dict(
            changed=True,
            requirements_file=self.requirements_file_name,
            pip=dict(
                present=pip_present,
                bin_path=self.pip_binary
            )
        )

    def pip_requirements(self, data):
        """
        """
        result = []

        valid_compare = [">=", "<=", ">", "<", "==", "!=", "~="]

        if isinstance(data, list):
            for entry in data:
                name = entry.get("name")
                compare_direction = entry.get("compare_direction", None)
                version = entry.get("version", None)
                versions = entry.get("versions", [])
                url = entry.get("url", None)

                if isinstance(version, str):
                    if compare_direction and compare_direction in valid_compare:
                        version = f"{compare_direction} {version}"
                    else:
                        version = f"== {version}"

                    result.append(f"{name} {version}")

                elif isinstance(versions, list) and len(versions) > 0:
                    valid_versions = [x for x in versions if x.startswith(tuple(valid_compare))]
                    versions = ", ".join(valid_versions)
                    result.append(f"{name} {versions}")

                elif isinstance(url, str):
                    result.append(f"{name} @ {url}")

                else:
                    result.append(name)

        return result


# ===========================================
# Module execution.
#


def main():

    args = dict(
        state=dict(
            choices=[
                "present",
                "absent",
            ],
            default="present"
        ),
        name=dict(
            type="str",
            required=True,
        ),
        requirements=dict(
            type="list",
            required=True,
        )
    )

    module = AnsibleModule(
        argument_spec=args,
        supports_check_mode=False,
    )

    obj = PipRequirements(module)
    result = obj.run()

    module.log(msg=f"= result: {result}")

    module.exit_json(**result)


# import module snippets
if __name__ == '__main__':
    main()
